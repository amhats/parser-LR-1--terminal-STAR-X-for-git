#define _GNU_SOURCE
#define __STDC_WANT_LIB_EXT2__ 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <omp.h>
#include <unistd.h>
#include <getopt.h>
#include "parser_helper.h"
#include "parser_type.h"
#include "parser_grammar.tab.h"
#include <readline/readline.h>			//uses GNU readline library for command line intarctive use
#include <readline/history.h>			//use GNU readline library to save input history


extern FILE* yyin;				//input buffer to parser buffer assigned to yyin
extern char *arg_filename;		//filename containing the input to be parsed 
extern int arg_test;			//boolean to specify test mode
extern char *current_input;		//hold the current input value of the parser

extern void yy_scan_string(char*);		//generated by yyparser, take string input rather than buffer input
extern void yylex_destroy();			//as the name suggest destroy input buffer

void print_bpas_intro();				//into to interactive parser
void handle_input(char* input);			//handles parser run non-interactivly mode that takes file as input
void Usage();							//how to use parser

int main(int argc, char* argv[]){
	print_bpas_intro();

	int c;

  	while (1) {
		static struct option long_options[] =
			{	
				{"test", no_argument, 0, 't'},						//test or t, set test flag arg_test
				{"file",    required_argument, 0, 'f'},				//file or f, save file name to global var arg_filename
				{0, 0, 0, 0}
			};
		int option_index = 0;
		c = getopt_long (argc, argv, "f:", long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
			case 't':
				arg_test = 1;
				break;
			case 'f':
				arg_filename = strdup(optarg);
				break;
			default:
				Usage();
				exit(EXIT_FAILURE);
		}
    }

	if(argc >= 2){
		handle_input(arg_filename);
		return 0;
	}else if(argc == 1){

		// do{
		// 	fprintf(stdout, ">> ");
		// 	yyparse();
		// }while(!feof(yyin));

		char *input = NULL;
		while(1){
			input = readline(">>> ");
			add_history(input);
			yy_scan_string(input);
			yyparse();
			free(input);
		}
	}

	return 0;
}

/**
 * @brief Intro to interactive parser
 * 
 */
void print_bpas_intro(){
	fprintf(stdout, "		BPAS version 0.0.0.1 BETA (EXPERIMENTAL) \n");
	fprintf(stdout, "		   	June 23, 2018 \n");
	fprintf(stdout, "			    :|		     \n");
}

/**
 * @brief parser usage.
 * 
 */
void Usage(){
	printf("Usage: parser [-t] -f <filename>\n");
}

/**
 * @brief Handles non-interactive takes input from a file
 * 
 * @param input 
 */
void handle_input(char* input){
	FILE *temp;
	temp = fopen(input, "r");
	if(!temp){
		parser_error("failed opening the file ", __FILE__, __func__, __LINE__);
	}
	
	fseek(temp, 0, SEEK_END);
	size_t size = ftell(temp);
	rewind(temp);
	
	char *buf = (char*)malloc(size*sizeof(char));
	if(buf == NULL){
		parser_error_with_errno_reason(PARSER_NOALLOC, __FILE__, __func__, __LINE__);
	}
	size_t r = fread(buf, sizeof(char), size, temp);
	
	char *newbuf = strip_comments(buf, size);		//comments are stripped off 
	free(buf);
	
	char *delim = ";";								//individual file inputs are separated by semi-colons
	char *result =  strtok(newbuf, delim);
	while(result != NULL){
		size_t ilen = strlen(result);
		for(int i =0; i<ilen+1; i++){
			if(result[i] == '\n')
				result[i] = ' ';
		}
		current_input = strdup(result);
		yy_scan_string(result);
		yyparse();
		yylex_destroy();
		result = strtok(NULL, delim);
	}
	free(newbuf);
	free(result);
}




































